//! This module provides a load thread that mod_load can use to load resources on the device if it supports multithreading;
//! currently only d3d11 devices (though I think d3d9 could support it, it wasn't the default unlike d3d11).
//! This avoids blocking the main render thread.  Without this there is a pause when resources are finally loaded onto the
//! device, especially if tangent space also needs updating, which can be quite long if the system is slow or running in 
//! low power mode (such as my laptop, which I underclock so that
//! I only get nearly 1st degree burns on my legs).
//! 
//! The load thread only loads one resource at a time.  It could do more, but there is some bad mojo around the device 
//! reference count that I made an attempt at preserving (and that probably isn't even correct on a multithreaded device).
//! Making it able to load more than one at a time also probaby involves looking at the managed code to make sure it can handle 
//! more than one thread in there.
//! 
//! Most of this code was initially generated by LLM (openai o3, though I used 4o for some helpers).  Which explains some of
//! the inane comments.  Other inane comments are ones I wrote.  
//! I did however come up with the scheme of cloning the native mod data and sending 
//! it over a channel to the thread, then overwriting the same entry for it in the mod database after load, 
//! which avoids the need for the load thread to lock the entire mod database when load completes.

use std::{
    collections::{hash_map::Entry, HashMap},
    sync::{
        mpsc::{self, Sender},
        Arc, LazyLock, Mutex, RwLock,
    },
    thread,
};

use global_state::GLOBAL_STATE;
use shared_dx::{types::DevicePointer, util::write_log_file};
use types::{interop::ManagedCallbacks, native_mod::NativeModData};

use crate::{get_dev_ref_count, get_mod_by_index, update_ref_count};
use crate::load_d3d_data11;

/// ─────────────────────────────── core types ──────────────────────────────
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum ResourceState {
    Loading,
    Loaded,
    Error(String),
}

type TableInner = Mutex<HashMap<i32, ResourceState>>;
type TableHandle = Arc<TableInner>;

/// Global pointer to *the current* resource table.
/// Read-lock for cheap look-ups, write-lock to swap in a fresh table.
pub static RESOURCE_TABLE: LazyLock<RwLock<TableHandle>> = LazyLock::new(|| {
    RwLock::new(Arc::new(Mutex::new(HashMap::new())))
});

use std::sync::atomic::{AtomicI32, Ordering};

// add a resource table id static which is an atomic int
static RESOURCE_TABLE_ID: AtomicI32 = AtomicI32::new(0);

// This function increments the resource table ID without returning it.
fn increment_resource_table_id() {
    RESOURCE_TABLE_ID.fetch_add(1, Ordering::SeqCst);
}
fn get_resource_table_id() -> i32 {
    RESOURCE_TABLE_ID.load(Ordering::SeqCst)
}

/// Helper: grab today’s active table.
fn current_table() -> TableHandle {
    RESOURCE_TABLE.read().unwrap().clone()
}

struct LoadMsg {
    device: DevicePointer,
    callbacks: ManagedCallbacks,
    nmod: NativeModData,
}
unsafe impl Send for LoadMsg {}

/// ───────────────── loader thread & queue initialisation ──────────────────
static LOAD_SENDER: LazyLock<Sender<LoadMsg>> = LazyLock::new(|| {
    let (tx, rx) = mpsc::channel::<LoadMsg>();

    // Dedicated loader thread.
    thread::spawn(move || {
        while let Ok(msg) = rx.recv() {
            let id = msg.nmod.midx;
            // Always use the table that is current *now*.
            let table = current_table();
            match load_resource(msg) {
                Ok(()) => match update_state(&table, id, ResourceState::Loaded) {
                    Ok(_) => (),
                    Err(x) => write_log_file(&format!("load thread error: failed to update load state for {id}: {x}")),
                },
                Err(x) => {
                    write_log_file(&format!("load thread error: resource {id}: {x}"));
                    match update_state(&table, id, ResourceState::Error(x)) {
                        Ok(_) => (),
                        Err(x) => write_log_file(&format!("load thread error: failed to update load state for {id}: {x}")),
                    }
                }
            }
        }
    });

    tx
});

/// Try to begin loading `id`.  
/// Returns `true` iff the ID was queued for the loader thread.
///
/// Spawn/queue rules:
/// * Absent   → queued, marked `Loading`.
/// * Anything else (`Loading`, `Loaded`, `Error`) → ignored.
pub fn maybe_start_load(device:DevicePointer, callbacks:ManagedCallbacks, nmod:&mut NativeModData) -> Result<bool, String> {
    use ResourceState::*;

    let table = current_table();
    let mut should_queue = false;

    let id = nmod.midx;
    // Decide under the per-table mutex.
    {
        
        let mut map = table.lock().map_err(|_| "maybe_start_load error: table mutex poisoned".to_string())?;
        match map.entry(id) {
            Entry::Vacant(v) => {
                v.insert(Loading);
                should_queue = true;
            }
            Entry::Occupied(mut o) 
                // do not reload if its already in the table for these states - in general the only way to get a reload
                // is to reload the whole mod database
                if ! matches!(o.get(), 
                    ResourceState::Loading | ResourceState::Error(_) | ResourceState::Loaded) => {
                o.insert(Loading);
                should_queue = true;
            }
            _ => {}
        }
    }

    // Push onto the queue (non-blocking) if required.
    if should_queue {
        let nmod = nmod.clone();
        let msg = LoadMsg {
            device,
            callbacks,
            nmod
        };
        // Handle the case when the loader thread has exited gracefully.
        LOAD_SENDER.send(msg).map_err(|_| "maybe_start_load error: loader thread gone".to_string())?;
    }

    Ok(should_queue)
}

/// This is called when the mod database is reloaded.  It just swaps out the whole table with a new one.  If the 
/// thread is loading a resource it will observe that the table id changed after it finished the load, and drop the 
/// resource.  Eventually a new load should be triggered for the resource if it is still relevant to something in the scene.
pub fn reinit_load_thread_table() -> Result<(), String>
{
    increment_resource_table_id();
    let new_map = HashMap::new();
    let new_handle = Arc::new(Mutex::new(new_map));
    *RESOURCE_TABLE.write().map_err(|_| "error: failed to acquire load thread table write lock".to_string())? = new_handle;
    Ok(())
}

fn load_resource(mut msg: LoadMsg) -> Result<(), String> {
    let id = msg.nmod.midx;
    let table_id = get_resource_table_id();
    unsafe {
        write_log_file(&format!("load thread: start loading #{id}"));
        let pre_rc = get_dev_ref_count(msg.device);

        let loaded = match msg.device {
            DevicePointer::D3D11(dev) => {
                load_d3d_data11(dev, msg.callbacks, msg.nmod.midx, &mut msg.nmod)
            },
            _ => {
                write_log_file("load thread error: load_resource can only handle d3d11 devices at this time; load request dropped");
                false
            }
        };

        let curr_table_id = get_resource_table_id();
        if curr_table_id != table_id {
            write_log_file(&format!("load thread: table changed while loading, dropping resource: {}", id));
        }
        else if loaded {
            let (diff,new_rc) = update_ref_count(msg.device, pre_rc);
            // i don't think its necessary to lock here because this is just a read of the hash table, though 
            // we'll overwrite the value if we find it
            if let Some(ref mut oldnmod) = get_mod_by_index(msg.nmod.midx, &mut GLOBAL_STATE.loaded_mods) {
                **oldnmod = msg.nmod.clone();
            }
            write_log_file(&format!("load thread: load_resource added {} to device rc, new rc: {}", diff, new_rc));
        }

        write_log_file(&format!("load thread: end loading #{id}"));
    }

    Ok(())
}

fn update_state(table: &TableHandle, id: i32, new_state: ResourceState) -> Result<(), String> {
    let mut map = table.lock().map_err(|_| "error: load thread table mutex poisoned".to_string())?;
    map.insert(id, new_state);
    Ok(())
}
